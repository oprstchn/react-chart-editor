{"version":3,"sources":["../../../../src/components/widgets/text_editors/convertFormats.js"],"names":["getTextBlockRegExp","getLaTeXWrappedRegExp","stripHTMLTags","html","replace","trim","extractTextBlocks","matchObj","matchStr","matches","stringifiedLaTeX","JSON","stringify","laTeX","regExp","exec","push","join","wrapLaTeX","value","wrapText","isLaTeXExpr","test","hasTextExpression","htmlToLaTeX","breakTag","trimmedHTML","split","map","para","length","laTeXToHTML","trimmedLaTeX"],"mappings":";;;;;AAAA,IAAMA,qBAAqB,SAArBA,kBAAqB;AAAA,SAAM;AAAN;AAAA,CAA3B;;AAEA;;;;;;AAMA,IAAMC,wBAAwB,SAAxBA,qBAAwB;AAAA,SAAM;AAAN;AAAA,CAA9B;;AAEA,IAAMC,gBAAgB,SAAhBA,aAAgB;AAAA,SAAQC,KAAKC,OAAL,CAAa,UAAb,EAAyB,EAAzB,EAA6BC,IAA7B,EAAR;AAAA,CAAtB;;AAEA,IAAMC,oBAAoB,SAApBA,iBAAoB,QAAS;AACjC,MAAIC,iBAAJ;AACA,MAAIC,iBAAJ;AACA,MAAMC,UAAU,EAAhB;;AAEA;AACA,MAAMC,mBAAmBC,KAAKC,SAAL,CAAeC,KAAf,CAAzB;AACA,MAAMC,SAASd,oBAAf;;AAEA;;;;;AAKA,SAAO,CAACO,WAAWO,OAAOC,IAAP,CAAYL,gBAAZ,CAAZ,MAA+C,IAAtD,EAA4D;AAC1DF,eAAWD,SAAS,CAAT,EAAYF,IAAZ,GAAmBD,OAAnB,CAA2B,KAA3B,EAAkC,EAAlC,CAAX;AACAK,YAAQO,IAAR,CAAaR,QAAb;AACD;;AAED,SAAOC,QAAQQ,IAAR,CAAa,MAAb,CAAP;AACD,CApBD;;AAsBA,IAAMC,YAAY,SAAZA,SAAY;AAAA,SAAUC,cAAYA,KAAZ,SAAuB,IAAjC;AAAA,CAAlB;;AAEA,IAAMC,WAAW,SAAXA,QAAW;AAAA,SAAUD,oBAAkBA,KAAlB,SAA6B,UAAvC;AAAA,CAAjB;;AAEA;AACA;;AAEO,IAAME,oCAAc,SAAdA,WAAc;AAAA,SAASpB,wBAAwBqB,IAAxB,CAA6BH,KAA7B,CAAT;AAAA,CAApB;;AAEA,IAAMI,gDAAoB,SAApBA,iBAAoB,QAAS;AACxC,MAAMT,SAASd,oBAAf;AACA,MAAMU,mBAAmBC,KAAKC,SAAL,CAAeC,KAAf,CAAzB;;AAEA,SAAOC,OAAOQ,IAAP,CAAYZ,gBAAZ,CAAP;AACD,CALM;;AAOA,IAAMc,oCAAc,SAAdA,WAAc,OAAQ;AACjC,MAAMC,WAAW,MAAjB;AACA,MAAMC,cAAcvB,KAAKE,IAAL,EAApB;;AAEA;AACA,MAAIqB,gBAAgB,EAApB,EAAwB;AACtB,WAAOR,UAAUE,UAAV,CAAP;AACD;;AAED;AACA,MAAIM,YAAYtB,OAAZ,CAAoBqB,QAApB,EAA8B,EAA9B,MAAsC,EAA1C,EAA8C;AAC5C,WAAOP,UAAUE,UAAV,CAAP;AACD;;AAED,SAAOF,UACLQ,YACGC,KADH,CACSF,QADT;;AAGE;AAHF,GAIGG,GAJH,CAIO;AAAA,WAASC,KAAKC,MAAL,GAAcV,SAASlB,cAAc2B,IAAd,CAAT,CAAd,GAA8C,EAAvD;AAAA,GAJP,EAKGZ,IALH,CAKQ,IALR,CADK,CAAP;AAQD,CAtBM;;AAwBA,IAAMc,oCAAc,SAAdA,WAAc,QAAS;AAClC,MAAMC,eAAenB,MAAMR,IAAN,EAArB;;AAEA,SAAOC,kBAAkB0B,YAAlB,CAAP;AACD,CAJM","file":"convertFormats.js","sourcesContent":["const getTextBlockRegExp = () => /\\\\text\\{([^}]*)}/g;\n\n/**\n * To match any character including newline whitespace, use `[\\s\\S]*`\n * instead of `.*`. http://stackoverflow.com/a/1068308\n *\n * @returns {RegExp} the regular expression\n */\nconst getLaTeXWrappedRegExp = () => /^\\$[\\s\\S]*\\$$/;\n\nconst stripHTMLTags = html => html.replace(/<[^>]*>/g, '').trim();\n\nconst extractTextBlocks = laTeX => {\n  let matchObj;\n  let matchStr;\n  const matches = [];\n\n  // Need to stringify to match literally on `\\t`.\n  const stringifiedLaTeX = JSON.stringify(laTeX);\n  const regExp = getTextBlockRegExp();\n\n  /**\n   * Find multiple matches with the ``//g` flag.\n   * The `RegExp.prototype.exec` API mutates the RegExp object.\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec#Finding_successive_matches\n   */\n  while ((matchObj = regExp.exec(stringifiedLaTeX)) !== null) {\n    matchStr = matchObj[1].trim().replace('\\\\n', '');\n    matches.push(matchStr);\n  }\n\n  return matches.join('<br>');\n};\n\nconst wrapLaTeX = value => (value ? `$${value}$` : '$$');\n\nconst wrapText = value => (value ? `\\\\text{${value}}` : '\\\\text{}');\n\n// Exports\n// -------\n\nexport const isLaTeXExpr = value => getLaTeXWrappedRegExp().test(value);\n\nexport const hasTextExpression = laTeX => {\n  const regExp = getTextBlockRegExp();\n  const stringifiedLaTeX = JSON.stringify(laTeX);\n\n  return regExp.test(stringifiedLaTeX);\n};\n\nexport const htmlToLaTeX = html => {\n  const breakTag = '<br>';\n  const trimmedHTML = html.trim();\n\n  // Handle empty input\n  if (trimmedHTML === '') {\n    return wrapLaTeX(wrapText());\n  }\n\n  // Handle input with only linebreaks\n  if (trimmedHTML.replace(breakTag, '') === '') {\n    return wrapLaTeX(wrapText());\n  }\n\n  return wrapLaTeX(\n    trimmedHTML\n      .split(breakTag)\n\n      // Ignore empty linebreaks\n      .map(para => (para.length ? wrapText(stripHTMLTags(para)) : ''))\n      .join('\\n')\n  );\n};\n\nexport const laTeXToHTML = laTeX => {\n  const trimmedLaTeX = laTeX.trim();\n\n  return extractTextBlocks(trimmedLaTeX);\n};\n"]}