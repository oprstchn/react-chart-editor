{"version":3,"sources":["../../src/lib/walkObject.js"],"names":["isPlainObject","makeAttrSetterPath","walkObject","input","Array","isArray","doArrayWalk","key","value","walkArrays","walkArraysMatchingKeys","includes","getPath","pathType","_path","set","parent","nextPath","concat","length","Error","get","parts","path","i0","i","_walkObject","object","callback","config","Object","keys","forEach"],"mappings":"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","file":"walkObject.js","sourcesContent":["export function isPlainObject(input) {\n  return input && !Array.isArray(input) && typeof input === 'object';\n}\n\n/*\n * Helper function for _walkObject\n */\nfunction doArrayWalk(key, value, walkArrays, walkArraysMatchingKeys) {\n  if (!Array.isArray(value)) {\n    return false;\n  }\n\n  if (walkArrays || (walkArraysMatchingKeys && walkArraysMatchingKeys.includes(key))) {\n    return true;\n  }\n\n  return false;\n}\n\n/*\n * Helper utility for path accumulation in _walkObject. Supports array\n * path accumulation and also Plotly.js nestedProperty style.\n */\nfunction getPath(pathType = 'array', _path) {\n  return {\n    _path: _path || (pathType === 'array' ? [] : ''),\n    set(parent, key) {\n      let nextPath;\n      switch (pathType) {\n        case 'array':\n          nextPath = this._path.concat([key]);\n          break;\n\n        case 'nestedProperty':\n          if (this._path.length === 0) {\n            nextPath = key;\n          } else if (Array.isArray(parent)) {\n            nextPath = this._path + `[${key}]`;\n          } else {\n            nextPath = this._path + '.' + key;\n          }\n          break;\n\n        default:\n          throw new Error('unrecognized pathType ' + pathType);\n      }\n\n      return getPath(pathType, nextPath);\n    },\n\n    get(parent, key) {\n      // in array mode we do not return the leaf node key.\n      if (pathType === 'array') {\n        return this._path;\n      }\n\n      // in nestedProperty mode we return full path including final key\n      return this.set(parent, key)._path;\n    },\n  };\n}\n\n/*\n * Helper function that transforms an array of path parts into a single path.\n * For example:\n *\n *  ['_fullData', 0, 'transforms', 3, 'type'] => 'transforms[3].type'\n *\n * Note that it strips out the _fullData part (and also _fullInput) since that's\n * usually present in the attribute path but isn't necessary in the attribute\n * string since it's usually implicitly applied through the userDataIndex.\n */\nexport function makeAttrSetterPath(parts) {\n  let path = '';\n\n  // Truncate the leading parts that aren't intersting when applying changes:\n  let i0 = 0;\n  if (parts[i0] === '_fullData') {\n    i0 += 2;\n  }\n  if (parts[i0] === '_fullInput') {\n    i0++;\n  }\n  if (parts[i0] === '_fullLayout') {\n    i0++;\n  }\n\n  for (let i = i0; i < parts.length; i++) {\n    if (typeof parts[i] === 'number' || Array.isArray(parts[i])) {\n      path += '[' + (Array.isArray(parts[i]) ? parts[i][0] : parts[i]) + ']';\n    } else {\n      path += (i > i0 ? '.' : '') + parts[i];\n    }\n  }\n  return path;\n}\n\n/**\n * The function that walkObject calls at each node.\n *\n * @callback walkObjectCallback\n * @param {string|number} key The current key, which may be nested.\n * @param {object} parent The object which owns the 'key' as a prop.\n * @param {Array} path The keys that lead to the 'parent' object.\n * @returns {boolean} True if the value at 'key' should *not* be traversed into\n *                    if it happens to be an object. I.e., you don't need to\n *                    return anything if you want the default traversal of the\n *                    whole object.\n */\n\n/**\n * Walks through object and recurses if necessary.\n *\n * @param {object} object The top-level or nested object we're walking through.\n * @param {walkObjectCallback} callback Called at each object node.\n * @param {Array} path The keys that lead from to top-level object to this one.\n * @param {object} config configuration object\n * @param {string} config.walkArrays flag allowing array walking\n * @param {Array} config.walkArraysMatchingKeys An array of keys permitting\n *                                              array walking\n * @param {string} config.pathType Either 'array' or 'nestedProperty'. Array\n *                                 based paths return string keys in an array up\n *                                 until the current key position.\n *                                 NestedProperty style returns a single\n *                                 concatenated \"nestedProperty\" style string.\n * @returns {void}\n * @private\n */\nfunction _walkObject(object, callback, path, config) {\n  const {walkArrays, walkArraysMatchingKeys} = config;\n  Object.keys(object).forEach(key => {\n    // Callback can force traversal to stop by returning `true`.\n    if (callback(key, object, path.get(object, key))) {\n      return;\n    }\n\n    const value = object[key];\n    if (isPlainObject(value) || doArrayWalk(key, value, walkArrays, walkArraysMatchingKeys)) {\n      _walkObject(value, callback, path.set(object, key), config);\n    }\n  });\n}\n\n/**\n * General function to walk object and call the given callback for each node.\n *\n * @param {Object|Array} input The object or array we want to walk.\n * @param {walkObjectCallback} callback Called at each object node.\n * @param {Object} [config] configuration object\n * @param {Boolean} [config.walkArrays] flag allowing array walking\n * @param {Array} [config.walkArraysMatchingKeys] An array of keys permitting\n *                                              array walking\n * @param {String} [config.pathType] Either 'array' or 'nestedProperty'. Array\n *                                   based paths return string keys in an array\n *                                   up until the current key position.\n *                                   NestedProperty style returns a single\n *                                   concatenated \"nestedProperty\" style string\n *                                   with the current key included in the path.\n *                                   Defaults to \"array\"\n * @returns {void}\n */\nexport default function walkObject(input, callback, config = {}) {\n  if (!isPlainObject(input) && !Array.isArray(input)) {\n    throw new Error('The input must be an object.');\n  }\n  var path = getPath(config.pathType);\n  _walkObject(input, callback, path, config);\n}\n"]}